#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <oqs/sig.h>
#include <oqs/rand.h>

#include "../ds_benchmark.h"

struct sig_testcase {
  enum OQS_SIG_scheme_id scheme_id;
  char* scheme_id_name;
  int run;
  int iter;
};

/* Add new testcases here */
struct sig_testcase sig_testcases[] = {
  {OQS_SIG_scheme_id_default, "default", 0, 100}, // TODO: replace with an actual scheme (FIXME)
};

#define SIG_TEST_ITERATIONS 100
#define SIG_BENCH_SECONDS 1

#define PRINT_HEX_STRING(label, str, len)                        \
	{                                                            \
		printf("%-20s (%4zu bytes):  ", (label), (size_t)(len)); \
		for (size_t i = 0; i < (len); i++) {                     \
			printf("%02X", ((unsigned char *) (str))[i]);        \
		}                                                        \
		printf("\n");                                            \
	}

static int sig_test_correctness(OQS_RAND *rand, enum OQS_SIG_scheme_id scheme_id, const int print, unsigned long occurrences[256]) {

	OQS_SIG *s = NULL;
	int rc;

	uint8_t *priv = NULL;
	uint8_t *pub = NULL;
	uint8_t *msg = NULL;
	size_t msg_len;
	uint8_t *sig = NULL;
	size_t sig_len;

	/* setup signature object */
	s = OQS_SIG_get(scheme_id);
	if (s == NULL) {
		fprintf(stderr, "get_method failed\n");
		goto err;
	}

	if (print) {
		printf("================================================================================\n");
		printf("Sample computation for signature method %s\n", s->scheme_id);
		printf("================================================================================\n");
	}

	/* key generation */
	priv = malloc(s->priv_key_len);
	if (priv == NULL) {
	  fprintf(stderr, "priv malloc failed\n");
	  goto err;
	}
	pub = malloc(s->pub_key_len);
	if (pub == NULL) {
	  fprintf(stderr, "pub malloc failed\n");
	  goto err;
	}

	rc = OQS_SIG_keygen(s, rand, priv, pub);
	if (rc != 1) {
		fprintf(stderr, "OQS_SIG_keygen failed\n");
		goto err;
	}

	if (print) {
		PRINT_HEX_STRING("Private key", priv, s->priv_key_len)
		PRINT_HEX_STRING("Public key", pub, s->pub_key_len)
	}

	/* Generate message to sign */
	msg_len = 100; // FIXME TODO: randomize based on scheme's max length
	msg = malloc(msg_len);
	if (msg == NULL) {
	  fprintf(stderr, "msg malloc failed\n");
	  goto err;
	}

	if (print) {
		PRINT_HEX_STRING("Message", msg, msg_len)
	}

	/* Signature */
	sig_len = s->max_sig_len;
	sig = malloc(sig_len);
	if (sig == NULL) {
	  fprintf(stderr, "sig malloc failed\n");
	  goto err;
	}
	
	rc = OQS_SIG_sign(s, rand, priv, msg, msg_len, sig, &sig_len);
	if (rc != 1) {
		fprintf(stderr, "OQS_SIG_sign failed\n");
		goto err;
	}

	if (print) {
		PRINT_HEX_STRING("Signature", sig, sig_len)
	}

	/* Verification */
	rc = OQS_SIG_verify(s, pub, msg, msg_len, sig, sig_len);
	if (rc != 1) {
		fprintf(stderr, "ERROR: OQS_SIG_verify failed\n");
		goto err;
	}

	if (print) {
		printf("Signature is valid.\n");
		printf("\n\n");
	}

#ifdef FIXME // TODO: is this needed?
	/* record generated bytes for statistical analysis */
	for (size_t i = 0; i < alice_key_len; i++) {
		OQS_RAND_test_record_occurrence(alice_key[i], occurrences);
	}
#else
	if (occurrences[0] == 0) {}; // to avoid unused param warning. TODO: delete this
#endif
	rc = 1;
	goto cleanup;

err:
	rc = 0;

cleanup:
	if (msg != NULL) { free(msg); }
	if (sig != NULL) { free(sig); }
	if (pub != NULL) { free(pub); }
	if (priv != NULL) { free(priv); }

	return rc;
}

static int sig_test_correctness_wrapper(OQS_RAND *rand, enum OQS_SIG_scheme_id scheme_id, int iterations, bool quiet) {
	OQS_SIG *s = NULL;
	int ret;

	unsigned long occurrences[256];
	for (int i = 0; i < 256; i++) {
		occurrences[i] = 0;
	}
	ret = sig_test_correctness(rand, scheme_id, !quiet, occurrences);
	if (ret != 1) {
		goto err;
	}

	/* setup signature object */
	s = OQS_SIG_get(scheme_id);
	if (s == NULL) {
		goto err;
	}

	printf("================================================================================\n");
	printf("Testing correctness and randomness of signature method %s for %d iterations\n",
	       s->scheme_id, iterations);
	printf("================================================================================\n");
	for (int i = 0; i < iterations; i++) {
		ret = sig_test_correctness(rand, scheme_id, 0, occurrences);
		if (ret != 1) {
			goto err;
		}
	}
	printf("All signatures were valid.\n");
#ifdef FIXME // TODO:needed?
	printf("Statistical distance from uniform: %12.10f\n", OQS_RAND_test_statistical_distance_from_uniform(occurrences));
#endif
	printf("\n\n");

	return 1;
 err:
	return ret;
}


static int sig_bench_wrapper(OQS_RAND *rand, enum OQS_SIG_scheme_id scheme_id, const int seconds) {

	OQS_SIG *s = NULL;
	int rc;

	uint8_t *priv = NULL;
	uint8_t *pub = NULL;
	uint8_t *msg = NULL;
	size_t msg_len;
	uint8_t *sig = NULL;
	size_t sig_len;

	/* setup signature object */
	s = OQS_SIG_get(scheme_id);
	if (s == NULL) {
		fprintf(stderr, "get_method failed\n");
		goto err;
	}
	/* key generation */
	priv = malloc(s->priv_key_len);
	if (priv == NULL) {
	  fprintf(stderr, "priv malloc failed\n");
	  goto err;
	}
	pub = malloc(s->pub_key_len);
	if (pub == NULL) {
	  fprintf(stderr, "pub malloc failed\n");
	  goto err;
	}

	printf("%-30s | %10s | %14s | %15s | %10s | %16s | %10s\n", s->scheme_id, "", "", "", "", "", "");

	TIME_OPERATION_SECONDS({ OQS_SIG_keygen(s, rand, priv, pub); }, "keygen", seconds);

	OQS_SIG_keygen(s, rand, priv, pub);
	/* Generate message to sign */
	msg_len = 100; // FIXME TODO: randomize based on scheme's max length
	msg = malloc(msg_len);
	if (msg == NULL) {
	  fprintf(stderr, "msg malloc failed\n");
	  goto err;
	}
	sig_len = s->max_sig_len;
	sig = malloc(sig_len);
	if (sig == NULL) {
	  fprintf(stderr, "sig malloc failed\n");
	  goto err;
	}

	TIME_OPERATION_SECONDS({ OQS_SIG_sign(s, rand, priv, msg, msg_len, sig, &sig_len); sig_len = s->max_sig_len; }, "sign", seconds);

	OQS_SIG_sign(s, rand, priv, msg, msg_len, sig, &sig_len);
	TIME_OPERATION_SECONDS({ OQS_SIG_verify(s, pub, msg, msg_len, sig, sig_len); }, "verify", seconds);
	
	rc = 1;
	goto cleanup;

err:
	rc = 0;

cleanup:
	free(priv);
	free(pub);
	free(msg);
	free(sig);

	return rc;
}

int main(int argc, char **argv) {

	int success = 1;
	bool run_all = true;
	bool quiet = false;
	bool bench = false;
	size_t sig_testcases_len = sizeof(sig_testcases) / sizeof(struct sig_testcase);
	for (int i = 1; i < argc; i++) {
		if (argv[i][0] == '-') {
			if ((strcmp(argv[i], "-h") == 0) || (strcmp(argv[i], "-help") == 0) || (strcmp(argv[i], "--help") == 0)) {
				printf("Usage: ./test_sig [options] [schemes]\n");
				printf("\nOptions:\n");
				printf("  --quiet, -q\n");
				printf("    Less verbose output\n");
				printf("  --bench, -b\n");
				printf("    Run benchmarks\n");
				printf("\nschemes:\n");
				for (size_t i = 0; i < sig_testcases_len; i++) {
					printf("  %s\n", sig_testcases[i].scheme_id_name);
				}
				return EXIT_SUCCESS;
			} else if (strcmp(argv[i], "--quiet") == 0 || strcmp(argv[i], "-q") == 0) {
				quiet = true;
			} else if (strcmp(argv[i], "--bench") == 0 || strcmp(argv[i], "-b") == 0) {
				bench = true;
			}

		} else {
			run_all = false;
			for (size_t j = 0; j < sig_testcases_len; j++) {
				if (strcmp(argv[i], sig_testcases[j].scheme_id_name) == 0) {
					sig_testcases[j].run = 1;
				}
			}
		}
	}

	/* setup RAND */
	OQS_RAND *rand = OQS_RAND_new(OQS_RAND_alg_urandom_chacha20);
	if (rand == NULL) {
		goto err;
	}

	for (size_t i = 0; i < sig_testcases_len; i++) {
		if (run_all || sig_testcases[i].run == 1) {
			int num_iter = sig_testcases[i].iter;
			success = sig_test_correctness_wrapper(rand, sig_testcases[i].scheme_id, num_iter, quiet);
		}
		if (success != 1) {
			goto err;
		}
	}

	if (bench) {
		PRINT_TIMER_HEADER
		for (size_t i = 0; i < sig_testcases_len; i++) {
			if (run_all || sig_testcases[i].run == 1) {
				sig_bench_wrapper(rand, sig_testcases[i].scheme_id, SIG_BENCH_SECONDS);
			}
		}
		PRINT_TIMER_FOOTER
	}

	success = 1;
	goto cleanup;

err:
	success = 0;
	fprintf(stderr, "ERROR!\n");

cleanup:
	OQS_RAND_free(rand);

	return (success == 1) ? EXIT_SUCCESS : EXIT_FAILURE;
}
